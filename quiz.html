<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenTelemetry Practice Quiz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .quiz-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
            padding: 40px;
            position: relative;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
        }

        .score {
            background: #f0f0f0;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
        }

        .question-text {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 25px;
            line-height: 1.4;
            color: #333;
        }

        .options {
            list-style: none;
            margin-bottom: 30px;
        }

        .option {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
        }

        .option:hover {
            background: #e3f2fd;
            border-color: #2196F3;
        }

        .option.selected {
            background: #e3f2fd;
            border-color: #2196F3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
        }

        .option.correct {
            background: #e8f5e8;
            border-color: #4CAF50;
            color: #2e7d32;
        }

        .option.incorrect {
            background: #ffebee;
            border-color: #f44336;
            color: #c62828;
        }

        .option-letter {
            font-weight: bold;
            margin-right: 12px;
            min-width: 20px;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .feedback {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: 500;
        }

        .feedback.correct {
            background: #e8f5e8;
            color: #2e7d32;
            border-left: 4px solid #4CAF50;
        }

        .feedback.incorrect {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #f44336;
        }

        .final-score {
            text-align: center;
            padding: 40px 20px;
        }

        .final-score h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .final-score .score-display {
            font-size: 3em;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
        }

        .section-info {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #666;
        }

        @media (max-width: 600px) {
            .quiz-container {
                padding: 20px;
            }
            
            .question-header {
                flex-direction: column;
                gap: 10px;
            }
            
            .buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div id="quizContent">
            <div class="question-header">
                <div class="question-number" id="questionNumber">Question 1 of 42</div>
                <div class="score" id="scoreDisplay">Score: 0/0</div>
            </div>
            
            <div class="section-info" id="sectionInfo"></div>
            
            <div class="question-text" id="questionText"></div>
            
            <ul class="options" id="optionsList"></ul>
            
            <div class="feedback" id="feedback" style="display: none;"></div>
            
            <div class="buttons">
                <button class="btn btn-primary" id="submitBtn" onclick="submitAnswer()">Submit Answer</button>
                <button class="btn btn-secondary" id="nextBtn" onclick="nextQuestion()" style="display: none;">Next Question</button>
            </div>
        </div>
    </div>

    <script>
        const questions = [
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "Which of the following is NOT a type of telemetry data collected in OpenTelemetry?",
                options: ["Logs", "Metrics", "Traces", "Alerts"],
                correct: 3,
                explanation: "OpenTelemetry collects logs, metrics, and traces. Alerts are generated by monitoring systems like Prometheus, not OpenTelemetry itself."
            },
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "What is the primary purpose of OpenTelemetry?",
                options: ["To store logs in a centralized database", "To provide a vendor-neutral observability framework", "To replace Kubernetes monitoring tools", "To send alerts to monitoring dashboards"],
                correct: 1,
                explanation: "OpenTelemetry is an open-source, vendor-neutral observability framework that enables standard telemetry collection."
            },
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "Which statement about semantic conventions in OpenTelemetry is true?",
                options: ["They provide standardized naming for telemetry data", "They are only applicable to traces, not logs or metrics", "They are optional and have no impact on observability", "They are automatically generated and cannot be customized"],
                correct: 0,
                explanation: "Semantic conventions ensure consistent naming and structuring of telemetry data across different services."
            },
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "Which is an example of a well-named metric in OpenTelemetry?",
                options: ["CPUUsageTotal", "cpu_usage_percentage", "node_cpu_seconds_total", "app.memory"],
                correct: 2,
                explanation: "OpenTelemetry follows semantic conventions that recommend using snake_case and including units in metric names."
            },
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "What is the primary benefit of structured logging?",
                options: ["It improves parsing and searching of logs", "It reduces the amount of storage required", "It replaces the need for traces", "It eliminates the need for metrics"],
                correct: 0,
                explanation: "Structured logs use a key-value format, making them easier to query, filter, and analyze."
            },
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "What are the three main telemetry signals in OpenTelemetry?",
                options: ["Logs, Events, Metrics", "Logs, Metrics, Traces", "Logs, Alarms, Metrics", "Metrics, Logs, Service Discovery"],
                correct: 1,
                explanation: "OpenTelemetry collects three types of telemetry signalsâ€”logs, metrics, and traces."
            },
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "What is the primary purpose of context propagation in OpenTelemetry?",
                options: ["To send logs between distributed systems", "To store logs in a central database", "To maintain trace relationships across services", "To collect application performance data"],
                correct: 2,
                explanation: "Context propagation ensures that traces remain linked as requests move between microservices."
            },
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "Which of the following telemetry signals help monitor distributed transactions?",
                options: ["Logs", "Traces", "Metrics", "Events"],
                correct: 1,
                explanation: "Traces help track distributed transactions, showing the flow of requests across different services."
            },
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "Which log level represents critical issues requiring immediate action?",
                options: ["DEBUG", "INFO", "WARN", "ERROR"],
                correct: 3,
                explanation: "ERROR logs indicate critical issues that require immediate attention."
            },
            {
                section: "Section 1: Observability Fundamentals (18%)",
                question: "Which best practice should be followed when adding labels to telemetry data?",
                options: ["Avoid high-cardinality labels", "Use timestamps as labels", "Store entire log messages in labels", "Use random values as label names"],
                correct: 0,
                explanation: "High-cardinality labels (e.g., user IDs) can cause performance issues in observability pipelines."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "What is the main difference between the OpenTelemetry API and SDK?",
                options: ["The API is used for instrumenting applications, while the SDK processes and exports data", "The API stores telemetry data, while the SDK retrieves it", "The SDK provides application interfaces, while the API only handles traces", "The API is required for tracing, but the SDK is optional"],
                correct: 0,
                explanation: "The API provides language-specific instrumentation, while the SDK handles processing and exporting."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "Which component is responsible for exporting telemetry data in OpenTelemetry?",
                options: ["Receiver", "Processor", "Exporter", "Aggregator"],
                correct: 2,
                explanation: "The exporter is responsible for sending telemetry data to backend systems."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "Which OpenTelemetry signal tracks the execution flow across multiple services?",
                options: ["Metrics", "Logs", "Traces", "Events"],
                correct: 2,
                explanation: "Traces capture execution flow across multiple services."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "Which of the following is NOT an official OpenTelemetry SDK language?",
                options: ["Go", "Java", "Ruby", "Swift"],
                correct: 3,
                explanation: "OpenTelemetry officially supports Go, Java, Python, and JavaScript, but Swift is not an official SDK."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "What is the purpose of context propagation in OpenTelemetry?",
                options: ["To synchronize configuration settings across services", "To ensure traces maintain their relationships across distributed services", "To collect logs efficiently in cloud environments", "To aggregate metrics before sending them to a backend"],
                correct: 1,
                explanation: "Context propagation ensures that spans remain connected across microservices."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "What is the primary role of the OpenTelemetry API?",
                options: ["To store telemetry data", "To define language-specific interfaces for instrumentation", "To aggregate telemetry data", "To send alerts to Prometheus"],
                correct: 1,
                explanation: "The API provides a standard way to add observability instrumentation."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "Which component is responsible for processing and exporting telemetry data?",
                options: ["API", "SDK", "CLI", "Logs Receiver"],
                correct: 1,
                explanation: "The SDK handles processing, filtering, and exporting telemetry data."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "What is the recommended way to sample traces in OpenTelemetry?",
                options: ["Sample all traces", "Use head-based or tail-based sampling", "Store all traces in logs", "Drop all traces after they are received"],
                correct: 1,
                explanation: "OpenTelemetry allows head-based and tail-based sampling to optimize telemetry collection."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "What is an OpenTelemetry Span?",
                options: ["A distributed log entry", "A segment of a trace representing a single operation", "A dashboard metric", "A collector configuration"],
                correct: 1,
                explanation: "A span represents an operation within a trace."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "Which SDK pipeline component modifies telemetry data before exporting?",
                options: ["Exporters", "Processors", "Receivers", "Agents"],
                correct: 1,
                explanation: "Processors modify telemetry data before exporting."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "Which OpenTelemetry API function is used to start a new trace span?",
                options: ["log_event()", "start_as_current_span()", "record_metric()", "set_label()"],
                correct: 1,
                explanation: "The function start_as_current_span() creates a new span in OpenTelemetry."
            },
            {
                section: "Section 2: The OpenTelemetry API and SDK (46%)",
                question: "Which component in the OpenTelemetry SDK is responsible for controlling the sampling of traces?",
                options: ["Exporter", "Processor", "Sampler", "Receiver"],
                correct: 2,
                explanation: "The Sampler in the OpenTelemetry SDK determines whether a trace should be recorded and exported. Different sampling strategies help control the volume of telemetry data collected."
            },
            {
                section: "Section 3: The OpenTelemetry Collector (26%)",
                question: "Which component of the OpenTelemetry Collector is responsible for receiving telemetry data?",
                options: ["Processor", "Exporter", "Receiver", "Transformer"],
                correct: 2,
                explanation: "Receivers ingest telemetry data in the OpenTelemetry Collector."
            },
            {
                section: "Section 3: The OpenTelemetry Collector (26%)",
                question: "Which of the following deployment models is NOT supported by the OpenTelemetry Collector?",
                options: ["Sidecar Agent", "Centralized Collector", "Kubernetes Operator", "Standalone Server"],
                correct: 2,
                explanation: "OpenTelemetry Collector supports sidecar, centralized, and standalone models, but not Kubernetes Operator."
            },
            {
                section: "Section 3: The OpenTelemetry Collector (26%)",
                question: "What does an OpenTelemetry Collector processor do?",
                options: ["Ingests data from various sources", "Applies transformations such as filtering and batching", "Exports telemetry data to a backend", "Stores telemetry data in a database"],
                correct: 1,
                explanation: "Processors modify and filter telemetry data before exporting."
            },
            {
                section: "Section 3: The OpenTelemetry Collector (26%)",
                question: "What is the purpose of an OpenTelemetry pipeline?",
                options: ["To define how telemetry data flows from receivers to exporters", "To store data in a time-series database", "To execute machine learning models on traces", "To secure telemetry data using encryption"],
                correct: 0,
                explanation: "The pipeline defines how data is collected, processed, and exported."
            },
            {
                section: "Section 3: The OpenTelemetry Collector (26%)",
                question: "Which of the following is a valid OpenTelemetry Collector exporter?",
                options: ["Kafka", "Elasticsearch", "Jaeger", "All of the above"],
                correct: 3,
                explanation: "OpenTelemetry Collector supports multiple exporters, including Kafka, Elasticsearch, and Jaeger."
            },
            {
                section: "Section 3: The OpenTelemetry Collector (26%)",
                question: "What is the role of the OpenTelemetry Collector?",
                options: ["To visualize logs and traces", "To ingest, process, and export telemetry data", "To store logs in a database", "To replace monitoring dashboards"],
                correct: 1,
                explanation: "The Collector acts as a processing hub for telemetry signals."
            },
            {
                section: "Section 3: The OpenTelemetry Collector (26%)",
                question: "Which OpenTelemetry Collector component is responsible for modifying data?",
                options: ["Receiver", "Exporter", "Processor", "Sampler"],
                correct: 2,
                explanation: "Processors modify telemetry data in the pipeline."
            },
            {
                section: "Section 3: The OpenTelemetry Collector (26%)",
                question: "What is the purpose of a batch processor in the OpenTelemetry Collector?",
                options: ["To store telemetry data in memory", "To reduce the number of telemetry requests", "To generate alerts", "To format telemetry data as JSON"],
                correct: 1,
                explanation: "Batch processors optimize performance by grouping telemetry data before export."
            },
            {
                section: "Section 3: The OpenTelemetry Collector (26%)",
                question: "Which OpenTelemetry Collector component sends telemetry data to backends?",
                options: ["Receiver", "Processor", "Exporter", "Transformer"],
                correct: 2,
                explanation: "Exporters send telemetry data to backend observability platforms."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "Which method can help reduce high-cardinality issues in OpenTelemetry metrics?",
                options: ["Using more labels in every metric", "Removing all labels from traces", "Avoiding unique identifiers in label values", "Storing metrics in JSON format"],
                correct: 2,
                explanation: "Unique values (e.g., user IDs) increase cardinality, causing performance issues."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "What is one common cause of missing spans in distributed traces?",
                options: ["Logs not being formatted correctly", "Context propagation being broken between services", "Not enough CPU resources being allocated", "Using an incorrect database schema"],
                correct: 1,
                explanation: "Missing spans often result from incorrect trace context propagation."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "How can schema management benefit an OpenTelemetry deployment?",
                options: ["It ensures backward compatibility when renaming metrics", "It compresses logs for better storage efficiency", "It prevents OpenTelemetry from exporting traces", "It enables dynamic service discovery"],
                correct: 0,
                explanation: "Schema management prevents breaking queries when renaming metrics."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "Which debugging step is recommended if no telemetry data is received in OpenTelemetry Collector?",
                options: ["Restart the database service", "Verify the receiver configuration", "Disable all traces", "Increase the trace sampling rate"],
                correct: 1,
                explanation: "Missing telemetry data is often due to misconfigured receivers."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "What is the recommended strategy for handling transient errors in OpenTelemetry pipelines?",
                options: ["Drop all failed telemetry data", "Implement retries with exponential backoff", "Use only synchronous processing", "Store errors in a separate database"],
                correct: 1,
                explanation: "Retry mechanisms help handle transient failures."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "Which issue is a sign of high-cardinality problems in OpenTelemetry?",
                options: ["Missing logs", "Metrics consuming excessive memory", "Logs not appearing in dashboards", "Incorrect trace IDs"],
                correct: 1,
                explanation: "High-cardinality labels lead to excessive memory consumption."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "What is the best strategy to avoid telemetry data loss?",
                options: ["Implement retries with exponential backoff", "Send all telemetry data in real time", "Store all data in logs", "Drop data with missing attributes"],
                correct: 0,
                explanation: "Retries prevent data loss in observability pipelines."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "What is a common cause of missing spans in distributed tracing?",
                options: ["Incorrect metric names", "Incorrect context propagation", "High CPU utilization", "Log file corruption"],
                correct: 1,
                explanation: "Context propagation errors can lead to missing spans."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "Which OpenTelemetry feature helps ensure schema consistency over time?",
                options: ["Schema Management", "Sampling", "Data Aggregation", "Span Naming"],
                correct: 0,
                explanation: "Schema management ensures metric consistency over time."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "What is the primary purpose of a dead letter queue in OpenTelemetry pipelines?",
                options: ["To optimize the performance of trace collection", "To store telemetry data that failed processing for later analysis and potential replay", "To compress historical telemetry data for long-term storage", "To encrypt sensitive information in trace spans"],
                correct: 1,
                explanation: "The primary purpose of a dead letter queue in OpenTelemetry is to act as a safety mechanism that stores telemetry data which couldn't be processed or exported successfully."
            },
            {
                section: "Section 4: Maintaining and Debugging Observability Pipelines (10%)",
                question: "In an OpenTelemetry Collector configuration, which of the following correctly implements a dead letter queue for failed trace exports?",
                options: [
                    "service:\n  pipelines:\n    traces:\n      receivers: [otlp]\n      processors: [batch]\n      exporters: [jaeger, prometheus]",
                    "exporters:\n  file:\n    path: /var/log/failed-telemetry.json\n    \nservice:\n  pipelines:\n    traces:\n      receivers: [otlp]\n      processors: [batch]\n      exporters: [jaeger]\n      on_error: file",
                    "receivers:\n  otlp:\n    protocols:\n      grpc:\n        error_handler: file_storage",
                    "extensions:\n  health_check:\n    endpoint: 0.0.0.0:13133\n  dead_letter:\n    path: /var/log/otel/"
                ],
                correct: 1,
                explanation: "This configuration correctly implements a dead letter queue by using the on_error directive in the pipeline configuration to route failed telemetry data to a file exporter."
            }
        ];

        let currentQuestion = 0;
        let score = 0;
        let selectedAnswer = null;
        let answered = false;

        function loadQuestion() {
            const question = questions[currentQuestion];
            
            document.getElementById('questionNumber').textContent = `Question ${currentQuestion + 1} of ${questions.length}`;
            document.getElementById('scoreDisplay').textContent = `Score: ${score}/${currentQuestion}`;
            document.getElementById('sectionInfo').textContent = question.section;
            document.getElementById('questionText').textContent = question.question;
            
            const optionsList = document.getElementById('optionsList');
            optionsList.innerHTML = '';
            
            question.options.forEach((option, index) => {
                const li = document.createElement('li');
                li.className = 'option';
                li.onclick = () => selectOption(index);
                li.innerHTML = `<span class="option-letter">${String.fromCharCode(65 + index)})</span>${option}`;
                optionsList.appendChild(li);
            });
            
            document.getElementById('feedback').style.display = 'none';
            document.getElementById('submitBtn').style.display = 'inline-block';
            document.getElementById('nextBtn').style.display = 'none';
            document.getElementById('submitBtn').disabled = true;
            
            selectedAnswer = null;
            answered = false;
            
            updateProgress();
        }

        function selectOption(index) {
            if (answered) return;
            
            const options = document.querySelectorAll('.option');
            options.forEach(option => option.classList.remove('selected'));
            options[index].classList.add('selected');
            
            selectedAnswer = index;
            document.getElementById('submitBtn').disabled = false;
        }

        function submitAnswer() {
            if (selectedAnswer === null || answered) return;
            
            answered = true;
            const question = questions[currentQuestion];
            const options = document.querySelectorAll('.option');
            const feedback = document.getElementById('feedback');
            
            options[question.correct].classList.add('correct');
            
            if (selectedAnswer === question.correct) {
                score++;
                feedback.className = 'feedback correct';
                feedback.innerHTML = `<strong>Correct!</strong> ${question.explanation}`;
            } else {
                options[selectedAnswer].classList.add('incorrect');
                feedback.className = 'feedback incorrect';
                feedback.innerHTML = `<strong>Incorrect.</strong> The correct answer is ${String.fromCharCode(65 + question.correct)}. ${question.explanation}`;
            }
            
            feedback.style.display = 'block';
            document.getElementById('submitBtn').style.display = 'none';
            document.getElementById('nextBtn').style.display = 'inline-block';
            
            document.getElementById('scoreDisplay').textContent = `Score: ${score}/${currentQuestion + 1}`;
        }

        function nextQuestion() {
            currentQuestion++;
            
            if (currentQuestion >= questions.length) {
                showFinalScore();
            } else {
                loadQuestion();
            }
        }

        function updateProgress() {
            const progress = (currentQuestion / questions.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }

        function showFinalScore() {
            const percentage = Math.round((score / questions.length) * 100);
            let grade = '';
            
            if (percentage >= 90) grade = 'Excellent!';
            else if (percentage >= 80) grade = 'Great job!';
            else if (percentage >= 70) grade = 'Good work!';
            else if (percentage >= 60) grade = 'Not bad!';
            else grade = 'Keep studying!';
            
            document.getElementById('quizContent').innerHTML = `
                <div class="final-score">
                    <h2>Quiz Complete!</h2>
                    <div class="score-display">${score}/${questions.length}</div>
                    <p style="font-size: 1.5em; margin: 20px 0;">${percentage}% - ${grade}</p>
                    <button class="btn btn-primary" onclick="restartQuiz()">Take Quiz Again</button>
                </div>
            `;
            
            document.getElementById('progressFill').style.width = '100%';
        }

        function restartQuiz() {
            currentQuestion = 0;
            score = 0;
            selectedAnswer = null;
            answered = false;
            
            document.getElementById('quizContent').innerHTML = `
                <div class="question-header">
                    <div class="question-number" id="questionNumber">Question 1 of 42</div>
                    <div class="score" id="scoreDisplay">Score: 0/0</div>
                </div>
                
                <div class="section-info" id="sectionInfo"></div>
                
                <div class="question-text" id="questionText"></div>
                
                <ul class="options" id="optionsList"></ul>
                
                <div class="feedback" id="feedback" style="display: none;"></div>
                
                <div class="buttons">
                    <button class="btn btn-primary" id="submitBtn" onclick="submitAnswer()">Submit Answer</button>
                    <button class="btn btn-secondary" id="nextBtn" onclick="nextQuestion()" style="display: none;">Next Question</button>
                </div>
            `;
            
            loadQuestion();
        }

        // Initialize the quiz
        loadQuestion();
    </script>
</body>
</html>